// apps/game-server/src/rooms/GameRoom.ts
import { Room, Client } from "@colyseus/core";
import { GameState } from "../game/GameState";
import { GameEngine } from "@rummikub/game-engine";

export class GameRoom extends Room<GameState> {
  private engine: GameEngine;
  private turnTimer: NodeJS.Timeout | null = null;

  onCreate(options: any) {
    this.setState(new GameState());
    this.engine = new GameEngine();
    this.maxClients = 4;
    this.autoDispose = false;

    // Message handlers
    this.onMessage("move", this.handleMove.bind(this));
    this.onMessage("draw", this.handleDraw.bind(this));
    this.onMessage("endTurn", this.handleEndTurn.bind(this));
    this.onMessage("chat", this.handleChat.bind(this));
    
    // Anti-cheat monitoring
    this.clock.setInterval(() => this.validateGameState(), 5000);
  }

  onJoin(client: Client, options: any) {
    const player = new Player();
    player.id = client.sessionId;
    player.username = options.username;
    player.avatar = options.avatar;
    
    this.state.players.set(client.sessionId, player);
    
    if (this.state.players.size === this.maxClients) {
      this.startGame();
    }
  }

  onLeave(client: Client, consented: boolean) {
    const player = this.state.players.get(client.sessionId);
    if (player) {
      player.connected = false;
      
      // Allow reconnection for 60 seconds
      this.allowReconnection(client, 60).then(() => {
        player.connected = true;
      }).catch(() => {
        // Player didn't reconnect, handle disconnect
        this.handleDisconnect(client.sessionId);
      });
    }
  }

  private handleMove(client: Client, data: MoveData) {
    // Validate move server-side
    const isValid = this.engine.validateMove(data);
    
    if (!isValid) {
      client.send("moveRejected", { reason: "Invalid move" });
      return;
    }
    
    // Apply move
    this.state.applyMove(data);
    
    // Broadcast to all clients
    this.broadcast("moveApplied", data);
  }

  private startTurnTimer() {
    const timeLimit = this.state.settings.turnTimeLimit * 1000;
    
    this.turnTimer = setTimeout(() => {
      this.handleTurnTimeout();
    }, timeLimit);
    
    // Broadcast timer start
    this.broadcast("timerStart", { duration: timeLimit });
  }
}